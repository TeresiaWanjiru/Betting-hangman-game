import { useEffect, useRef, useState } from 'react';
// import morning from './images/morning.png';
// import night from './images/night.png';
// import noon from './images/noon.png';
import style from './Keyboard.module.css';
import two from './images/two.jpg';
import three from './images/three.jpg';
import four from './images/four.jpg';
import five from './images/five.jpg';

const IMAGES = [two, three, four, five];

const BackgroundImage = () => {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const [imageIndex, setImageIndex] = useState<number>(0);
  const lastTimestamp = useRef(0);
  const fadeInDuration = 5000;
  const fadeOutDuration = 3000;
  const stayDuration = 3000;

  useEffect(() => {
    const canvas = canvasRef.current;
    const context = canvas?.getContext('2d');

    if (!canvas || !context) {
      console.error('Canvas or context is not available');
      return;
    }

    const images = IMAGES.map((src) => {
      const img = new Image();
      img.src = src;
      return img;
    });

    const img = images[imageIndex];

    const canvasWidth = 800;
    const canvasHeight = 600;

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    context.imageSmoothingEnabled = false;

    const drawImage = (alpha: number) => {
      context.globalAlpha = alpha;

      const scaleX = canvasWidth / img.width;
      const scaleY = canvasHeight / img.height;

      const scaleFactor = Math.max(scaleX, scaleY);

      const scaledWidth = img.width * scaleFactor;
      const scaledHeight = img.height * scaleFactor;

      const x = (canvasWidth - scaledWidth) / 2;
      const y = (canvasHeight - scaledHeight) / 2;

      context.clearRect(0, 0, canvas.width, canvas.height);
      context.drawImage(img, x, y, scaledWidth, scaledHeight);
      context.globalAlpha = 1;
    };

    console.log('img width and height', img.width, img.height);
    const fadeTransition = (timestamp: DOMHighResTimeStamp) => {
      const elapsed = timestamp - lastTimestamp.current;

      if (elapsed < fadeInDuration) {
        // Fade in
        const alpha = elapsed / fadeInDuration;
        drawImage(alpha);
        requestAnimationFrame(fadeTransition);
      } else if (elapsed < fadeInDuration + stayDuration) {
        // Stay on screen
        drawImage(1);
        requestAnimationFrame(fadeTransition);
      } else if (elapsed < fadeInDuration + stayDuration + fadeOutDuration) {
        // Fade out
        const alpha =
          1 - (elapsed - fadeInDuration - stayDuration) / fadeOutDuration;
        drawImage(alpha);
        requestAnimationFrame(fadeTransition);
      } else {
        // Switch to the next image after the entire sequence
        lastTimestamp.current = timestamp;
        setImageIndex((prevIndex) => (prevIndex + 1) % IMAGES.length);
        fadeTransition(timestamp);
      }
    };

    fadeTransition(0);

    return () => {
      context.clearRect(0, 0, canvas.width, canvas.height);
    };
  }, [imageIndex]);

  return <canvas ref={canvasRef} className={style.fadeInImage} />;
};

export default BackgroundImage;
